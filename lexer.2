/* 
   To do:
   Unterminated comments and strings (unsure if lexer or parser handles the error)
*/

#include "lex.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

unsigned int line = 1;

int tokens_index = 0;
int lexeme_index = 0;
int char_class;

#define COMMENT_CLASS 0
#define LETTER 1
#define DIGIT 2
#define OTHER 3

Token *lex(FILE *file) {
	int type;
	
	// stores all tokens
	int number_of_tokens = 12; // placeholder value for number of tokens
  	int tokens_size = 0;
    Token *tokens = malloc(sizeof(Token) * number_of_tokens); // array of all tokens in file
  	if (!tokens) {
        perror("Failed to allocate memory for tokens");
        exit(EXIT_FAILURE);
    }

	// finds length of file
	fseek(file, 0, SEEK_END);
    int length = ftell(file);
    fseek(file, 0, SEEK_SET);

	char *lexeme = malloc(sizeof(char) * (length + 1));
	if (!lexeme) {
        perror("Failed to allocate memory for lexeme");
        free(tokens);
        exit(EXIT_FAILURE);
    }
    
    char ch;
	
    while((ch = getNonBlank(file)) != EOF) {
    	lexeme[lexeme_index++] = ch; // builds lexeme by character
        
    	Token *token = malloc(sizeof(Token)); // allocates memory for current token
	    if (!token) {
            perror("Failed to allocate memory for token");
            free(tokens);
            free(lexeme);
            exit(EXIT_FAILURE);
        }
        tokens_size++;

	    if (tokens_size >= number_of_tokens) {
            reallocMemory(&tokens, &number_of_tokens);
        }

        int state = 0;
		// limit function calls by grouping tokens based on composition
		switch(char_class) {
			case COMMENT_CLASS:
                lexeme[lexeme_index++] = getc(file);
                storeToken(token, tokens, lexeme, COMMENT_BEGIN);

                lexeme_index = 0;
                Token *token1 = malloc(sizeof(Token));;

                while(state != 2) {
                    ch = getNextChar(file);

                    if(ch == EOF) {
                        storeToken(token1, tokens, lexeme, COMMENT);
                        tokens_size++;
                        if (tokens_size >= number_of_tokens) {
                            reallocMemory(&tokens, &number_of_tokens);
                        }
                        break; // Exit early for EOF
                    }

                    switch (state) {
                        case 0:
                            if (ch == ':') {
                                state = 1;
                                
                            } else {
                                lexeme[lexeme_index++] = ch;
                            }
                            break;
                        case 1: 
                            if (ch == '>') {
                                state = 2; // accept the input
                            } else {
                                lexeme[lexeme_index++] = ':';
                                lexeme[lexeme_index++] = ch;
                                state = 0; // check for ':' input again
                            }
                            break;
                    }
                } // end of while(state != 2)

                if(lexeme_index != 0 && ch != EOF){
                    // Store the non-blank block comment content
                    storeToken(token, tokens, lexeme, COMMENT);
                    tokens_size++;
                    if (tokens_size >= number_of_tokens) {
                        reallocMemory(&tokens, &number_of_tokens);
                    }
                }

                if(state == 2) {
                    lexeme_index = 2;
                    Token *token2 = malloc(sizeof(Token));;
                    strcpy(lexeme, ":>");
                    storeToken(token2, tokens, lexeme, COMMENT_END);
                    tokens_size++;
                    if (tokens_size >= number_of_tokens) {
                        reallocMemory(&tokens, &number_of_tokens);
                    }
                }
				break;

			case LETTER: // tokens containing only letters
				ch = getNextChar(file);
				while(isalpha(ch) && ch != '\n' && ch != EOF) {
					lexeme[lexeme_index++] = ch;
					ch = getNextChar(file);
				} 
				
				if(isdigit(ch)) { // takes lexemes beginning with letters but containing numbers
					while(!(isspace(ch)) && ch != '\n' && ch != EOF) {
						lexeme[lexeme_index++] = ch;
						ch = getNextChar(file);
					}
					storeToken(token, tokens, lexeme, INVALID);
					break;
				}
				
				lexeme[lexeme_index] = '\0';
				ungetc(ch, file);
				
				if(isKeyword(token, tokens, lexeme, ch, &type)) {
		            storeToken(token, tokens, lexeme, type);
		    	} else if(isReservedWord(lexeme, ch, &type)) {
		            storeToken(token, tokens, lexeme, type);
				} else {
		    		storeToken(token, tokens, lexeme, INVALID);
				}
		    	break;
		    	
			case DIGIT: // numeric literals
				if(isNumLiteral(lexeme, ch, &type, file)) {
					storeToken(token, tokens, lexeme, type);
				} else {
					storeToken(token, tokens, lexeme, INVALID);
				}
				break;
				
			case OTHER: // tokens that have non-alpanumeric characters
				if(isIdentifier(lexeme, ch, &type, file)) {
          		  	storeToken(token, tokens, lexeme, type);
		        } else if(isDelimiter(ch, &type)) {
					storeToken(token, tokens, lexeme, type);

                    if(type == DBL_QUOTE) {
                        lexeme_index = 0;
                        ch = getNextChar(file);
                        
                        while(ch != '"' && ch != '\n' && ch != EOF) {
                            lexeme[lexeme_index++] = ch; 
                            ch = getNextChar(file);
                        }

                        Token *token = malloc(sizeof(Token)); // allocates memory for current token
                        storeToken(token, tokens, lexeme, STRING);
                        tokens_size++;
                        if (tokens_size >= number_of_tokens) {
                            reallocMemory(&tokens, &number_of_tokens);
                        }
                        lexeme_index = 0;

                        if(ch == '"') {
                            Token *token = malloc(sizeof(Token));
                            lexeme[lexeme_index++] = ch;
                            storeToken(token, tokens, lexeme, DBL_QUOTE);
                            lexeme_index = 0;
                            tokens_size++;
                            if (tokens_size >= number_of_tokens) {
                                reallocMemory(&tokens, &number_of_tokens);
                            }
                        } else {
                            ungetc(ch, file);
                        }
                    } else if(type == SNGL_QUOTE){                                    
                        lexeme_index = 0;
                        ch = getNextChar(file);

                        if(ch != EOF && ch != '\n' && ch != '\''){
                            lexeme[lexeme_index++] = ch;
                            Token *token = malloc(sizeof(Token));
                            storeToken(token, tokens, lexeme, CHARACTER);
                            tokens_size++;
                            if (tokens_size >= number_of_tokens) {
                                reallocMemory(&tokens, &number_of_tokens);
                            }
                            lexeme_index = 0;
                            ch = getNextChar(file);
                        }

                        if(ch == '\''){
                            Token *token = malloc(sizeof(Token));
                            lexeme[lexeme_index++] = ch;
                            storeToken(token, tokens, lexeme, SNGL_QUOTE);
                            tokens_size++;
                            if (tokens_size >= number_of_tokens) {
                                reallocMemory(&tokens, &number_of_tokens);
                            }
                        } else{
                            ungetc(ch, file);
                        }
                    }
				} else if(isOperator(lexeme, ch, &type, file)) {
            		storeToken(token, tokens, lexeme, type);
            	} else {
	        		storeToken(token, tokens, lexeme, INVALID);
				}
            	break;
            	
			default:
				strcpy("Unknown exception", lexeme);
	        	storeToken(token, tokens, lexeme, INVALID);
		} // end of switch(char_class)
		lexeme_index = 0;	
        if(ch == EOF){
            break;
        }
    } // end of while(ch != EOF)

    tokens[tokens_index].value = NULL; // appends null terminator to indicate the end of tokens
    tokens[tokens_index].type = END_OF_TOKENS;
    tokens[tokens_index].line = line;
    free(lexeme);
    return tokens;
} //end of Token *lex

int isNumLiteral(char *lexeme, char ch, int *type, FILE *file) {
	int lexeme_index = 0;
    int state = 0;

    lexeme[lexeme_index++] = ch;

    while(1){
        switch (state) {
            case 0:
                switch (ch) {
                    case '0' ... '9':
                        state = 1;
                        break;
                    case '.':
                        state = 2;
                        break;
                    deafult:
                        lexeme[lexeme_index] = '\0';
                        return INVALID;
                }
                break;

            case 1:
                ch = getNextChar(file);
                switch (ch){
                    case '0' ... '9':
                        lexeme[lexeme_index++] = ch;
                        break;
                    case '.':
                        state = 3;
                        lexeme[lexeme_index++] = ch;
                        break;
                    default:
                        ungetc(ch, file);
                        lexeme[lexeme_index] = '\0';
                        *type = INTEGER;
                }
                break;

            case 2:
                ch = getNextChar(file);
                switch (ch){
                    case '0' ... '9':
                    state = 3;
                    lexeme[lexeme_index++] = ch;
                    break;
                default:
                    ungetc(ch, file);
                    lexeme[lexeme_index] = '\0';
                    return INVALID;
                }
                break;

            case 3:
                ch = getNextChar(file);
                switch (ch){
                    case '0' ... '9':
                        lexeme[lexeme_index++] = ch;
                        break;
                    default:
                        ungetc(ch, file);
                        lexeme[lexeme_index] = '\0';
                        *type = FLOAT;
                        return 1;
                }
                break;

            default:
                lexeme[lexeme_index] = '\0';
                return INVALID_TOKEN;
        }
    }
}

int isIdentifier(char *lexeme, char ch, int *type, FILE *file) {
	int state = 0;
	int lexeme_index = 0;

    while (1){
        switch(state){
            case 0: 
                switch (ch){
                    case '#':
                        state = 3;
                        lexeme[lexeme_index++] = ch;
                        ch = getNextChar(file);
                        break;
                    case '~':
                        state = 1;
                        lexeme[lexeme_index++] = ch;
                        ch = getNextChar(file);
                        break;
                    default: return 0; 
                }
                break;
            
            case 1:
                switch(ch) {
                    case 'a' ... 'z': //lowercase letters
                    state = 2;
                    lexeme[lexeme_index++] = ch;
                    ch = getNextChar(file);
                    break;
                default:
                    while(!(isspace(ch) || ch == '\n' || ch == '\t')) {
                        lexeme[lexeme_index++] = ch;
                        ch = getNextChar(file);
                    }
                    ungetc(ch, file);
                    *type = INVALID;
                    return 0;
                }
                break;

            case 2:
                switch(ch) {
                    case 'a' ... 'z': //lowercase letters
                    case 'A' ... 'Z':
                    case '0' ... '9':
                        lexeme[lexeme_index++] = ch;
                        ch = getNextChar(file);
                        break;
                    default:
                        ungetc(ch,file);
                        lexeme[lexeme_index] = '\0';
                        *type = FUNC_IDENT;
                        return 1;
                }
                break;

            case 3:
                switch(ch) {
                    case 'a' ... 'z':
                        state = 4;
                        lexeme[lexeme_index++] = ch;
                        ch = getNextChar(file);
                        break;
                default:
                    while(!(isspace(ch) || ch == '\n' || ch == '\t')) {
                        lexeme[lexeme_index++] = ch;
                        ch = getNextChar(file);
                    }
                    ungetc(ch,file);
                    *type = INVALID;
                    return 0;
                }
                break;

                case 4: 
                    switch(ch) {
                        case 'a' ... 'z':
                        case 'A' ... 'Z':
                        case '0' ... '9':
                            lexeme[lexeme_index++] = ch;
                            ch = getNextChar(file);
                            break;
                        default:
                            ungetc(ch, file);
                            lexeme[lexeme_index] = '\0';
                            *type = VAR_IDENT;
                            return 1;
                    }
                    break;
            default:
                *type = INVALID;
                return 0;
                
        }
    }
}

int isKeyword(Token *token, Token *tokens, char *lexeme, char ch, int *type) {
	int i = 0;  // Index for lexeme
    ch = lexeme[i];  // Start by checking the first character
    int state = 0;

    while (lexeme[i] != '\0') {
        switch (state) {
            case 0: // Initial state
                switch (lexeme[i]) {
                    case 'b': state = 1; break;  // beegin, beegone, buzz, buzzout
                    case 'c': state = 16; break; // case
                    case 'd': state = 20; break; // do, default
                    case 'e': state = 28; break; // else, elseif
                    case 'f': state = 34; break; // for
                    case 'g': state = 37; break; // gather
                    case 'h': state = 43; break; // hive, hover
                    case 'i': state = 51; break; // if
                    case 'q': state = 53; break; // queenbee
                    case 'r': state = 61; break; // return
                    case 's': state = 67; break; // sting, switch
                    case 'w': state = 77; break; // while
                    default: return 0; // Not a keyword
                }
                break;

            case 1: // 'b'
                switch (lexeme[i]) {
                    case 'e': state = 2; break;  // beegin, beegone
                    case 'u': state = 10; break; // buzz, buzzout
                    default: return 0;
                }
                break;
            case 2: // 'be'
                state = (lexeme[i] == 'e') ? 3 : 0;
                break;
            case 3: // 'bee'
                state = (lexeme[i] == 'g') ? 4 : 0;
                break;
            case 4: // 'beeg'
                switch (lexeme[i]) {
                    case 'i': state = 5; break;  // beegin
                    case 'o': state = 7; break;  // beegone
                    default: return 0;
                }
                break;
            case 5: // 'beegi'
                state = (lexeme[i] == 'n') ? 6 : 0;
                break;
            case 6: // Final state for 'beegin'
                return (lexeme[i] == '\0') ? (*type = BEEGIN_TOKEN, 1) : 0;
            case 7: // 'beego'
                state = (lexeme[i] == 'n') ? 8 : 0;
                break;
            case 8: // 'beegon'
                state = (lexeme[i] == 'e') ? 9 : 0;
                break;
            case 9: // Final state for 'beegone'
                return (lexeme[i] == '\0') ? (*type = BEEGONE_TOKEN, 1) : 0;
            case 10: // 'bu'
                state = (lexeme[i] == 'z') ? 11 : 0;
                break;
            case 11: // 'buz'
                state = (lexeme[i] == 'z') ? 12 : 0;
                break;
            case 12: // 'buzz'
                switch (lexeme[i]) {
                    case '\0': return (*type = BUZZ_TOKEN, 1); // Final state for 'buzz'
                    case 'o': state = 13; break;      // buzzout
                    default: return 0;
                }
                break;
            case 13: // 'buzzo'
                state = (lexeme[i] == 'u') ? 14 : 0;
                break;
            case 14: // 'buzzou'
                state = (lexeme[i] == 't') ? 15 : 0;
                break;
            case 15: // Final state for 'buzzout'
                return (lexeme[i] == '\0') ? (*type = BUZZOUT_TOKEN, 1) : 0;

            // States for 'case'
            case 16: // 'c'
                state = (lexeme[i] == 'a') ? 17 : 0;
                break;
            case 17: // 'ca'
                state = (lexeme[i] == 's') ? 18 : 0;
                break;
            case 18: // 'cas'
                state = (lexeme[i] == 'e') ? 19 : 0;
                break;
            case 19: // Final state for 'case'
                return (lexeme[i] == '\0') ? (*type = CASE_TOKEN, 1) : 0;

            // States for 'do' and 'default'
            case 20: // 'd'
                switch (lexeme[i]) {
                    case 'o': state = 21; break;
                    case 'e': state = 22; break;
                    default: return 0;
                }
                break;
            case 21: // Final state for 'do'
                return (lexeme[i] == '\0') ? (*type = DO_TOKEN, 1) : 0;
            case 22: // 'de'
                state = (lexeme[i] == 'f') ? 23 : 0;
                break;
            case 23: // 'def'
                state = (lexeme[i] == 'a') ? 24 : 0;
                break;
            case 24: // 'defa'
                state = (lexeme[i] == 'u') ? 25 : 0;
                break;
            case 25: // 'defau'
                state = (lexeme[i] == 'l') ? 26 : 0;
                break;
            case 26: // 'defaul'
                state = (lexeme[i] == 't') ? 27 : 0;
                break;
            case 27: // Final state for 'default'
                return (lexeme[i] == '\0') ? (*type = DEFAULT_TOKEN, 1) : 0;

            // States for 'else' and 'elseif'
            case 28: // 'e'
                state = (lexeme[i] == 'l') ? 29 : 0;
                break;
            case 29: // 'el'
                state = (lexeme[i] == 's') ? 30 : 0;
                break;
            case 30: // 'els'
                state = (lexeme[i] == 'e') ? 31 : 0;
                break;
            case 31: // Final state for 'else'
                switch (lexeme[i]) {
                    case '\0': return (*type = ELSE_TOKEN, 1);
                    case 'i': state = 32; break;
                    default: return 0;
                }
                break;
            case 32: // 'elsei'
                state = (lexeme[i] == 'f') ? 33 : 0;
                break;
            case 33: // Final state for 'elseif'
                return (lexeme[i] == '\0') ? (*type = ELSEIF_TOKEN, 1) : 0;

            // States for 'for'
            case 34:
                state = (lexeme[i] == 'o') ? 35 : 0;
                break;
            case 35:
                state = (lexeme[i] == 'r') ? 36 : 0;
                break;
            case 36: // Final state for 'for'
                return (lexeme[i] == '\0') ? (*type = FOR_TOKEN, 1) : 0;

            // States for 'gather'
            case 37:
                state = (lexeme[i] == 'a') ? 38 : 0;
                break;
            case 38:
                state = (lexeme[i] == 't') ? 39 : 0;
                break;
            case 39:
                state = (lexeme[i] == 'h') ? 40 : 0;
                break;
            case 40:
                state = (lexeme[i] == 'e') ? 41 : 0;
                break;
            case 41:
                state = (lexeme[i] == 'r') ? 42 : 0;
                break;
            case 42: // Final state for 'gather'
                return (lexeme[i] == '\0') ? (*type = GATHER_TOKEN, 1) : 0;

            // States for 'hive' and 'hover'
            case 43:
                switch (lexeme[i]) {
                    case 'i': state = 44; break; // hive
                    case 'o': state = 47; break; // hover
                    default: return 0;
                }
                break;
            case 44:
                state = (lexeme[i] == 'v') ? 45 : 0;
                break;
            case 45:
                state = (lexeme[i] == 'e') ? 46 : 0;
                break;
            case 46: // Final state for 'hive'
                return (lexeme[i] == '\0') ? (*type = HIVE_TOKEN, 1) : 0;

            case 47:
                state = (lexeme[i] == 'v') ? 48 : 0;
                break;
            case 48:
                state = (lexeme[i] == 'e') ? 49 : 0;
                break;
            case 49:
                state = (lexeme[i] == 'r') ? 50 : 0;
                break;
            case 50: // Final state for 'hover'
                return (lexeme[i] == '\0') ? (*type = HOVER_TOKEN, 1) : 0;

            // States for 'if'
            case 51:
                state = (lexeme[i] == 'f') ? 52 : 0;
                break;
            case 52: // Final state for 'if'
                return (lexeme[i] == '\0') ? (*type = IF_TOKEN, 1) : 0;

            // States for 'queenbee'
            case 53:
                state = (lexeme[i] == 'u') ? 54 : 0;
                break;
            case 54:
                state = (lexeme[i] == 'e') ? 55 : 0;
                break;
            case 55:
                state = (lexeme[i] == 'e') ? 56 : 0;
                break;
            case 56:
                state = (lexeme[i] == 'n') ? 57 : 0;
                break;
            case 57:
                state = (lexeme[i] == 'b') ? 58 : 0;
                break;
            case 58:
                state = (lexeme[i] == 'e') ? 59 : 0;
                break;
            case 59:
                state = (lexeme[i] == 'e') ? 60 : 0;
                break;
            case 60: // Final state for 'queenbee'
                return (lexeme[i] == '\0') ? (*type = QUEENBEE_TOKEN, 1) : 0;

            // States for 'return'
            case 61:
                state = (lexeme[i] == 'e') ? 62 : 0;
                break;
            case 62:
                state = (lexeme[i] == 't') ? 63 : 0;
                break;
            case 63:
                state = (lexeme[i] == 'u') ? 64 : 0;
                break;
            case 64:
                state = (lexeme[i] == 'r') ? 65 : 0;
                break;
            case 65:
                state = (lexeme[i] == 'n') ? 66 : 0;
                break;
            case 66: // Final state for 'return'
                return (lexeme[i] == '\0') ? (*type = RETURN_TOKEN, 1) : 0;

            // States for 'sting' and 'switch'
            case 67:
                switch (lexeme[i]) {
                    case 't': state = 68; break; // sting
                    case 'w': state = 72; break; // switch
                    default: return 0;
                }
                break;
            case 68:
                state = (lexeme[i] == 'i') ? 69 : 0;
                break;
            case 69:
                state = (lexeme[i] == 'n') ? 70 : 0;
                break;
            case 70:
                state = (lexeme[i] == 'g') ? 71 : 0;
                break;
            case 71: // Final state for 'sting'
                return (lexeme[i] == '\0') ? (*type = STING_TOKEN, 1) : 0;

            case 72: // switch
                state = (lexeme[i] == 'i') ? 73 : 0;
                break;
            case 73:
                state = (lexeme[i] == 't') ? 74 : 0;
                break;
            case 74:
                state = (lexeme[i] == 'c') ? 75 : 0;
                break;
            case 75:
                state = (lexeme[i] == 'h') ? 76 : 0;
                break;
            case 76: // Final state for 'switch'
                return (lexeme[i] == '\0') ? (*type = SWITCH_TOKEN, 1) : 0;

            // States for 'while'
            case 77:
                state = (lexeme[i] == 'h') ? 78 : 0;
                break;
            case 78:
                state = (lexeme[i] == 'i') ? 79 : 0;
                break;
            case 79:
                state = (lexeme[i] == 'l') ? 80 : 0;
                break;
            case 80:
                state = (lexeme[i] == 'e') ? 81 : 0;
                break;
            case 81: // Final state for 'while'
                return (lexeme[i] == '\0') ? (*type = WHILE_TOKEN, 1) : 0;

            default:
                return 0; // Not a valid keyword
        }
        i++;
    }
}



int isReservedWord(char *lexeme, char ch, int *type) {
	int i = 0;  // Index for lexeme
    ch = lexeme[i];  // Start by checking the first character
    int state;

    while (ch != '\0'){
        switch (state) {
            switch (ch) {
                case 'b': state = 1; break; //bool
                case 'c': state = 5; break; //chain char
                case 'f': state = 11; break;
                case 'i': state = 20; break;
                case 't': state = 23; break;
                default: return 0;
            }
            break;

            case 1: // 'b'
                state = (lexeme[i] == 'o') ? 2 : 0;
                break;
            case 2: // 'bo'
                state = (lexeme[i] == 'o') ? 3 : 0;
                break;
            case 3: // 'boo'
                state = (lexeme[i] == 'l') ? 4 : 0;
                break;
            case 4: // Final state for 'bool'
                return (lexeme[i] == '\0') ? (*type = BOOL_TOKEN, 1) : 0;

            // States for 'chain' and 'char'
            case 5: // 'c'
                state = (lexeme[i] == 'h') ? 6 : 0;
                break;
            case 6: // 'ch'
                state = (lexeme[i] == 'a') ? 7 : 0;
                break;
            case 7: // 'cha'
                switch (lexeme[i]) {
                    case 'i': state = 8; break;
                    case 'r': state = 10; break;
                    default: return 0;
                }
                break;
            case 8: // 'chai'
                state = (lexeme[i] == 'n') ? 9 : 0;
                break;
            case 9: // Final state for 'chain'
                return (lexeme[i] == '\0') ? (*type = CHAIN_TOKEN, 1) : 0;
            case 10: // Final state for 'char'
                return (lexeme[i] == '\0') ? (*type = CHAR_TOKEN, 1) : 0;

            // States for 'false' and 'float'
            case 11: // 'f'
                switch (lexeme[i]) {
                    case 'a': state = 12; break;
                    case 'l': state = 16; break;
                    default: return 0;
                }
                break;
            case 12: // 'fa'
                state = (lexeme[i] == 'l') ? 13 : 0;
                break;
            case 13: // 'fal'
                state = (lexeme[i] == 's') ? 14 : 0;
                break;
            case 14: // 'fals'
                state = (lexeme[i] == 'e') ? 15 : 0;   
                break;
            case 15: // Final state for 'false'
                return (lexeme[i] == '\0') ? (*type = FALSE_TOKEN, 1) : 0;
            case 16: // 'fl'
                state = (lexeme[i] == 'o') ? 17 : 0;
                break;
            case 17: // 'flo'
                state = (lexeme[i] == 'a') ? 18 : 0;
                break;
            case 18: // 'floa'
                state = (lexeme[i] == 't') ? 19 : 0;
                break;
            case 19: // Final state for 'float'
                return (lexeme[i] == '\0') ? (*type = FLOAT_TOKEN, 1) : 0;

            // States for 'int'
            case 20: // 'i'
                state = (lexeme[i] == 'n') ? 21 : 0;
                break;
            case 21: // 'in'
                state = (lexeme[i] == 't') ? 22 : 0;
                break;
            case 22: // Final state for 'int'
                return (lexeme[i] == '\0') ? (*type = INT_TOKEN, 1) : 0;

            // States for 'true'
            case 23: // 't'
                state = (lexeme[i] == 'r') ? 24 : 0;
                break;
            case 24: // 'tr'
                state = (lexeme[i] == 'u') ? 25 : 0;
                break;
            case 25: // 'tru'
                state = (lexeme[i] == 'e') ? 26 : 0;
                break;
            case 26: // Final state for 'true'
                return (lexeme[i] == '\0') ? (*type = TRUE_TOKEN, 1) : 0;

            default:
                return 0; // Not a valid reserved word
        }
        i++;
    }

    // Check final states and assign token types
    switch (state) {
        case 4:  *type = BOOL_TOKEN; return 1;   // bool
        case 9:  *type = CHAIN_TOKEN; return 1;  // chain
        case 10: *type = CHAR_TOKEN; return 1;   // char
        case 15: *type = FALSE_TOKEN; return 1;  // false
        case 19: *type = FLOAT_TOKEN; return 1;  // float
        case 22: *type = INT_TOKEN; return 1;    // int
        case 26: *type = TRUE_TOKEN; return 1;   // true
        default: return 0;
    }
}
        
    
	


int isDelimiter(char ch, int *type) {
	switch (ch) {
        case ';':
    		*type = SEMICOLON;
    		return 1;
        case ',':
    		*type = COMMA;
    		return 1;
        case '(':
    		*type = LEFT_PAREN;
    		return 1;
        case ')':
    		*type = RIGHT_PAREN;
    		return 1;
        case '[':
    		*type = LEFT_BRACKET;
    		return 1;
        case ']':
    		*type = RIGHT_BRACKET;
    		return 1;
        case '{':
    		*type = LEFT_BRACE;
    		return 1;
        case '}':
    		*type = RIGHT_BRACE;
    		return 1;
        case '"':
    		*type = DBL_QUOTE;
    		return 1;
        case '\'':
            *type = SNGL_QUOTE;
    		return 1;
        case ':':
            *type = COLON;
            return 1;
        default:
            return 0; // not a delimiter
    }
}

int isOperator(char *lexeme, char ch, int *type, FILE *file) {
	switch(ch) {
    	case '+':	
    		*type = ADDITION;
            ch = getc(file);
            if(ch == '+') {
                *type = INCREMENT;
                lexeme[lexeme_index++] = ch;
                return 1;
            } else {
				ungetc(ch, file);
	    	}
    		return 1;
    	case '-':
    		*type = SUBTRACTION;
            ch = getc(file);
            if(ch == '-') {
                *type = DECREMENT;
                lexeme[lexeme_index++] = ch;
                return 1;
            } else {
				ungetc(ch, file);
	    	}
    		return 1;
    	case '*':
    		*type = MULTIPLICATION;
    		return 1;
    	case '/':
            ch = getc(file);
            if(ch == '/') {
                *type = INT_DIVISION;
                lexeme[lexeme_index++] = ch;
                return 1;
            } else {
                *type = DIVISION;
				ungetc(ch, file);
                return 1;
	    	}
    	case '%':
    		*type = MODULO;
    		return 1;
    	case '^':
    		*type = EXPONENT;
    		return 1;
		case '>':
    		ch = getNextChar(file);
    		if(ch == '=') {
    			lexeme[lexeme_index++] = ch;
    			*type = GREATER_EQUAL;
    			return 1;
			} else {
				ungetc(ch, file);
	    		*type = GREATER_THAN;
	    		return 1;	
	    	}
    	case '<':
    		ch = getNextChar(file);
    		if(ch == '=') {
    			lexeme[lexeme_index++] = ch;
    			*type = LESS_EQUAL;
    			return 1;
			} else {
				ungetc(ch, file);
	    		*type = LESS_THAN;
	    		return 1;	
	    	}
    	case '=':
    		ch = getNextChar(file);
    		if(ch == '=') {
    			lexeme[lexeme_index++] = ch;
    			*type = IS_EQUAL_TO;
    			return 1;
			} else {
				ungetc(ch, file);
	    		*type = ASSIGNMENT_OP;
	    		return 1;	
	    	}
	   	case '&':
    		ch = getNextChar(file);
    		if(ch == '&') {
    			lexeme[lexeme_index++] = ch;
    			*type = AND;
    			return 1;
			} else {
				ungetc(ch, file);
				return 0;
	    	}
	    case '|':
    		ch = getNextChar(file);
    		if(ch == '|') {
    			lexeme[lexeme_index++] = ch;
    			*type = OR;
    			return 1;
			} else {
				ungetc(ch, file);
				return 0;
	    	}
	   	case '!':
    		ch = getNextChar(file);
    		if(ch == '=') {
    			lexeme[lexeme_index++] = ch;
    			*type = NOT_EQUAL;
    			return 1;;
			} else {
				ungetc(ch, file);
	    		*type = NOT;
	    		return 1;	
	    	}
    	default:
    		return 0; // not an operator
	}
}

// return any character including spaces or newlines
char getNextChar(FILE *file) {
	char ch = fgetc(file), temp;
	
	// seperate characters by class
	if(ch == '<') {
		temp = getc(file);
        if(temp == '|') {
            char_class = COMMENT_CLASS;
            ungetc(temp, file);
        } else {
            char_class = OTHER;
            ungetc(temp, file);
        }
	} else if(isalpha(ch)) {
		char_class = LETTER;
	} else if(isdigit(ch)) {
		char_class = DIGIT;
	} else {
		char_class = OTHER;
	} 

	return ch;
}

// skip whitespaces and newline
char getNonBlank(FILE *file) {
	char ch = getNextChar(file);
	
	while(isspace(ch) || ch == '\t' || ch == '\n') {
		if(ch == '\n') {
    		line++;
		}
		ch = getNextChar(file);
	}
	
	return ch;
}

void storeToken(Token *token, Token *tokens, char *lexeme, int type) {
    lexeme[lexeme_index] = '\0';
    token->value = malloc(strlen(lexeme) + 1);
    strcpy(token->value, lexeme);
    token->line = line;
    token->type = type;
    
    tokens[tokens_index] = *token;
    tokens_index++;
}

void reallocMemory(Token **tokens, int *number_of_tokens) {
    *number_of_tokens *= 2;
    Token *new_tokens = realloc(*tokens, sizeof(Token) * *number_of_tokens);
    if (!new_tokens) {
        perror("Failed to reallocate memory for tokens");
        free(*tokens);
        exit(EXIT_FAILURE);
    }
    *tokens = new_tokens; // Update the caller's pointer
}
