Node *parseSwitchStmt() {
    Node *node = createNode("<switch_stmt>");

    // Check for 'switch' token
    if (peekToken()->type == SWITCH_TOKEN) {
        addChild(node, createNode(peekToken()->value));
        advanceToken();

        // Check for '(' after 'switch'
        if (peekToken()->type == LEFT_PAREN) {
            advanceToken();
            Node *condition = parseExpression();
            if (condition) {
                addChild(node, condition);

                // Check for ')' after condition
                if (peekToken()->type == RIGHT_PAREN) {
                    advanceToken();

                    // Check for '{' to start the switch body
                    if (peekToken()->type == LEFT_BRACE) {
                        addChild(node, createNode(peekToken()->value));
                        advanceToken();
                        
                        // Parse case and default clauses
                        while (peekToken()->type == CASE_TOKEN || peekToken()->type == DEFAULT_TOKEN) {
                            if (peekToken()->type == CASE_TOKEN) {
                                addChild(node, parseCaseClause());
                            } else {
                                addChild(node, parseDefaultClause());
                            }
                        }
                        
                        // Check for '}' to close the switch body
                        if (peekToken()->type == RIGHT_BRACE) {
                            addChild(node, createNode(peekToken()->value));
                            advanceToken();
                        } else {
                            errorMessage("Expected '}' after switch statement");
                            addChild(node, createNode("Error"));
                            errorRecovery();
                            hasError = 1;
                        }
                    } else {
                        errorMessage("Expected '{' after condition in switch statement");
                        addChild(node, createNode("Error"));
                        errorRecovery();
                        hasError = 1;       
                    }
                } else {
                    errorMessage("Expected ')' after switch condition");
                    addChild(node, createNode("Error"));
                    errorRecovery();
                    hasError = 1;
                }
            } else {
                errorMessage("Expected expression inside switch condition");
                addChild(node, createNode("Error"));
                errorRecovery();
                hasError = 1;
            }
        } else {
            errorMessage("Expected '(' after switch keyword");
            addChild(node, createNode("Error"));
            errorRecovery();
            hasError = 1;
        }
    }

    return node;
}

Node *parseCaseClause() {
    Node *node = createNode("<case_clause>");

    // Check for 'case' token
    if (peekToken()->type == CASE_TOKEN) {
        addChild(node, createNode(peekToken()->value));
        advanceToken();
        
        // Check for a valid value after 'case'
        if (isValue(peekToken()->type)) {
            addChild(node, createNode(peekToken()->value));
            advanceToken();
            
            // Check for ':' after case value
            if (peekToken()->type == COLON) {
                addChild(node, createNode(peekToken()->value));
                advanceToken();
                
                // Parse statements within the case clause
                while (peekToken()->type != CASE_TOKEN && 
                       peekToken()->type != DEFAULT_TOKEN && 
                       peekToken()->type != RIGHT_BRACE && 
                       peekToken()->type != EOF) {
                    if (peekToken()->type == STING_TOKEN) {
                        addChild(node, createNode("sting"));
                        advanceToken();
                        if (peekToken()->type == SEMICOLON) {
                            advanceToken();
                        } else {
                            errorMessage("Expected ';' after 'sting'");
                            addChild(node, createNode("Error"));
                            errorRecovery();
                            hasError = 1;
                        }
                        break;
                    } else {
                        addChild(node, parseStmt());
                    }
                }
            } else {
                errorMessage("Expected ':' after case value");
                addChild(node, createNode("Error"));
                errorRecovery();
                hasError = 1;
            }
        } else {
            errorMessage("Expected value after 'case'");
            addChild(node, createNode("Error"));
            errorRecovery();
            hasError = 1;
        }
    }

    return node;
}

Node *parseDefaultClause() {
    Node *node = createNode("<default_clause>");

    // Check for 'default' token
    if (peekToken()->type == DEFAULT_TOKEN) {
        addChild(node, createNode(peekToken()->value));
        advanceToken();

        // Check for ':' after 'default'
        if (peekToken()->type == COLON) {
            addChild(node, createNode(peekToken()->value));
            advanceToken();

            // Parse statements within the default clause
            while (peekToken()->type != CASE_TOKEN && 
                   peekToken()->type != DEFAULT_TOKEN && 
                   peekToken()->type != RIGHT_BRACE && 
                   peekToken()->type != EOF) {
                if (peekToken()->type == STING_TOKEN) {
                    addChild(node, createNode("sting"));
                    advanceToken();
                    if (peekToken()->type == SEMICOLON) {
                        advanceToken();
                    } else {
                        errorMessage("Expected ';' after 'sting'");
                        addChild(node, createNode("Error"));
                        errorRecovery();
                        hasError = 1;
                    }
                    break;
                } else {
                    addChild(node, parseStmt());
                }
            }
        } else {
            errorMessage("Expected ':' after 'default'");
            addChild(node, createNode("Error"));
            errorRecovery();
            hasError = 1;
        }
    }

    return node;
}
